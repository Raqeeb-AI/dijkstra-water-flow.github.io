<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Dijkstra's Algorithm for Water Distribution - A Creative Web Presentation">
    <title>Dijkstra's Algorithm - Water Flow Optimization</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            background-color: #000;
            color: #fff;
        }

        header {
            background-color: #007bff;
            color: white;
            padding: 20px;
            text-align: center;
        }

        nav {
            text-align: center;
            margin: 20px 0;
        }

        nav button {
            background: linear-gradient(145deg, #007bff, #005f99);
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 0 10px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s, background-color 0.3s;
        }

        nav button:hover {
            background-color: #00bfff;
            transform: scale(1.1);
        }

        section {
            max-width: 800px;
            margin: 20px auto;
            padding: 20px;
            line-height: 1.6;
        }

        section h2 {
            color: #00bfff;
        }

        footer {
            background-color: #333;
            color: white;
            text-align: center;
            padding: 10px 0;
            margin-top: 20px;
        }
    </style>
</head>
<body>

    <header>
        <h1 style="font-family: 'Comfortaa', cursive; font-weight: 700; font-size: 2.5em; color: #fff;">DIJKSTRA'S ALGORITHM FOR WATER DISTRIBUTION</h1>
    </header>

    <nav>
        <button onclick="showSection('problem')">Problem</button>
        <button onclick="showSection('algorithm')">Algorithm</button>
        <button onclick="showSection('code')">Code</button>
    </nav>

    <section id="problem">
        <h2>Problem Statement</h2>
        <p>
            Efficiently routing water from a source to various destinations in an urban area to minimize cost, energy consumption, and water loss. The goal is to determine the shortest path in a complex pipeline network, represented as a graph with nodes (junctions) and edges (pipelines with weights representing distance or cost).
        </p>
        <h3 style="color: #00bfff;">Why is it Important?</h3>
        <p>
            Water distribution is a critical infrastructure in any city. Without proper optimization, water loss due to inefficient routing, leaks, and high energy consumption can lead to resource wastage and increased costs. Ensuring an efficient distribution system improves water availability, reduces costs, and supports sustainable urban development.
        </p>
        <h3 style="color: #00bfff;">What Happens When it is Solved?</h3>
        <p>
            Solving the problem leads to several key benefits:
        </p>
        <ul>
            <li><strong>Reduced Operational Costs</strong>: Optimized routing minimizes the length of pipelines and the energy required for pumping water.</li>
            <li><strong>Lower Water Loss</strong>: Efficient paths reduce leak-prone areas, leading to less wastage.</li>
            <li><strong>Improved Water Availability</strong>: Faster and more reliable water delivery ensures that all parts of the city receive adequate supply.</li>
            <li><strong>Sustainability</strong>: Enhancing water distribution efficiency contributes to long-term sustainability and environmental conservation.</li>
        </ul>
        </section>

    <section id="algorithm" style="display: none;">
        <h2>Algorithm Chosen: Dijkstra's Algorithm</h2>
        <p>
            Dijkstra's Algorithm is a well-known graph traversal algorithm used to find the shortest path from a source node to all other nodes in a weighted graph with non-negative edge weights. It is widely applied in scenarios where efficiency and accuracy are critical, such as network routing and urban planning.
        </p>
        <h3>Why Dijkstra's Algorithm?</h3>
        <p>
            Dijkstra's Algorithm is chosen over other algorithms because:
        </p>
        <ul>
            <li><strong>Efficiency</strong>: Dijkstra's algorithm has a time complexity of O((V + E) log V) using a binary heap, making it suitable for large, sparse graphs.</li>
            <li><strong>Guaranteed Optimal Solution</strong>: It always finds the shortest path in graphs with non-negative edge weights.</li>
            <li><strong>Simplicity</strong>: Compared to other algorithms like A* and Bellman-Ford, Dijkstra's algorithm is relatively easier to implement and understand.</li>
        </ul>
        <h3>Comparison with Bellman-Ford</h3>
        <p>
            While the Bellman-Ford algorithm can handle graphs with negative edge weights, it has a higher time complexity of O(VE), making it less efficient for large graphs. Since water distribution networks do not involve negative edge weights, Dijkstra's algorithm is a more appropriate choice.
        </p>
        <h3>Time and Space Complexity</h3>
        <p>
            <strong>Time Complexity</strong>: O((V + E) log V), where V is the number of vertices and E is the number of edges. This complexity is achieved using a binary heap for the priority queue.
        </p>
        <p>
            <strong>Space Complexity</strong>: O(V + E), as we need to store the graph (adjacency list) and the distance table.
        </p>
    </section>

    <section id="algorithm" style="display: none;">
        <h2>Algorithm Explanation</h2>
        <p>
            Dijkstra's Algorithm is a graph-based algorithm used to find the shortest path from a source node to all other nodes in a weighted graph. It involves the following steps:
        </p>
        <ol>
            <li><strong>Initialization</strong>: Set the distance of the source node to 0 and all other nodes to infinity.</li>
            <li><strong>Find Minimum Distance</strong>: Select the node with the smallest distance that hasn't been processed yet.</li>
            <li><strong>Update Distances</strong>: For each unvisited neighbor, calculate the new tentative distance (current distance + edge weight). If this distance is smaller, update it.</li>
            <li><strong>Repeat</strong>: Continue the process until all nodes have been processed.</li>
        </ol>
    </section>

    <section id="code" style="display: none;">
        <h2>Code Implementation</h2>
        <pre>
<code>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;limits.h&gt;

using namespace std;

void dijkstra(vector<vector<pair<int, int>>> &graph, int src) {
    int n = graph.size();
    vector<int> dist(n, INT_MAX);
    dist[src] = 0;
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    pq.push({0, src});

    while (!pq.empty()) {
        int u = pq.top().second;
        pq.pop();

        for (auto &neighbor : graph[u]) {
            int v = neighbor.first;
            int weight = neighbor.second;
            if (dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                pq.push({dist[v], v});
            }
        }
    }

    cout << "Shortest distances from source node " << src << ":
";
    for (int i = 0; i < n; i++) {
        cout << "To node " << i << " : " << dist[i] << "
";
    }
}

int main() {
    vector<vector<pair<int, int>>> graph = {
        {{1, 4}, {2, 1}},       // Node 0 connections: (1, 4), (2, 1)
        {{3, 1}},                // Node 1 connections: (3, 1)
        {{1, 2}, {3, 5}},        // Node 2 connections: (1, 2), (3, 5)
        {}                       // Node 3 connections: No outgoing edges
    };

    int source = 0;
    dijkstra(graph, source);

    return 0;
}
</code>
        </pre>
    </section>

    <footer>
        <p>&copy; 2025 Dijkstra's Algorithm Project | Water Distribution Optimization</p>
    </footer>

    <script>
        function showSection(sectionId) {
            const sections = document.querySelectorAll('section');
            sections.forEach(section => section.style.display = 'none');
            document.getElementById(sectionId).style.display = 'block';
        }
    </script>

</body>
</html>

